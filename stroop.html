  <script>
    function fitForSingle(mathEl, maxFontSize = 300, minFontSize = 80) {
      mathEl.style.fontSize = maxFontSize + "px";
      if (!mathEl.offsetWidth) return;
      const containerWidth = mathEl.parentElement.clientWidth;
      let currentSize = maxFontSize;
      while (mathEl.scrollWidth > containerWidth && currentSize > minFontSize) {
        currentSize -= 4;
        mathEl.style.fontSize = currentSize + "px";
      }
    }

    function fitForDual(mathEl, maxFontSize = 300, minFontSize = 80) {
      mathEl.style.fontSize = maxFontSize + "px";
      if (!mathEl.offsetWidth) return;
      const containerWidth = mathEl.parentElement.clientWidth;
      let currentSize = maxFontSize;
      while (mathEl.scrollWidth > containerWidth && currentSize > minFontSize) {
        currentSize -= 4;
        mathEl.style.fontSize = currentSize + "px";
      }
    }

    const COLOR_BASE = [
      { word: "Á¥ÖËâ≤", char: "Á¥Ö", color: "#e53935" },
      { word: "ÈªÉËâ≤", char: "ÈªÉ", color: "#fbc02d" },
      { word: "ËóçËâ≤", char: "Ëóç", color: "#1e88e5" },
      { word: "Á∂†Ëâ≤", char: "Á∂†", color: "#43a047" },
      { word: "ÈªëËâ≤", char: "Èªë", color: "#000000" },
      { word: "Ê£ïËâ≤", char: "Ê£ï", color: "#8d6e63" },
      { word: "Á¥´Ëâ≤", char: "Á¥´", color: "#8e24aa" },
      { word: "Ê©ôËâ≤", char: "Ê©ô", color: "#fb8c00" },
      { word: "ÁÅ∞Ëâ≤", char: "ÁÅ∞", color: "#555555" }
    ];

    function randInt(min,max){
      return Math.floor(Math.random()*(max-min+1))+min;
    }
    function randomPick(arr) {
      return arr[randInt(0, arr.length - 1)];
    }

    function makeSingleQuestion(isNormal) {
      if (isNormal) {
        const base = randomPick(COLOR_BASE);
        return { mode: "single", char: base.char, inkColor: base.color, type: "normal" };
      } else {
        let wordBase, colorBase;
        do {
          wordBase = randomPick(COLOR_BASE);
          colorBase = randomPick(COLOR_BASE);
        } while (wordBase.word === colorBase.word);
        return { mode: "single", char: wordBase.char, inkColor: colorBase.color, type: "stroop" };
      }
    }

    function makeDualQuestion() {
      function oneSide(isNormal) {
        if (isNormal) {
          const base = randomPick(COLOR_BASE);
          return { char: base.char, inkColor: base.color, type: "normal" };
        } else {
          let wordBase, colorBase;
          do {
            wordBase = randomPick(COLOR_BASE);
            colorBase = randomPick(COLOR_BASE);
          } while (wordBase.word === colorBase.word);
          return { char: wordBase.char, inkColor: colorBase.color, type: "stroop" };
        }
      }
      const patterns = [
        { left: "normal", right: "stroop" },
        { left: "stroop", right: "normal" },
        { left: "stroop", right: "stroop" }
      ];
      const pat = randomPick(patterns);
      return {
        mode: "dual",
        left: oneSide(pat.left === "normal"),
        right: oneSide(pat.right === "normal")
      };
    }

    function buildQuestionList(total, level) {
      const list = [];
      while (list.length < total) {
        const group = [];
        if (level === 1) {
          group.push(makeSingleQuestion(true));
          for (let i = 0; i < 3; i++) group.push(makeSingleQuestion(false));
        } else if (level === 2) {
          group.push(makeSingleQuestion(true));
          for (let i = 0; i < 5; i++) group.push(makeSingleQuestion(false));
        } else {
          // Level IIIÔºöÂÖ®ÈÉ®ÈõôÂ≠óÈ°å
          for (let i = 0; i < 6; i++) group.push(makeDualQuestion());
        }
        for (let i = group.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [group[i], group[j]] = [group[j], group[i]];
        }
        list.push(...group);
      }
      return list.slice(0, total);
    }

    let questions = [];
    let currentIndex = -1;

    let timer = 0;
    let totalSteps = 0;
    let intervalId = null;
    let isRunning = false;
    let isPaused = false;
    let musicEnabled = false;

    let lastLoopTime = 0;
    let lastStepTime = 0;
    let stepInterval = 60000 / 180;
    let nextQuestionTime = 0;

    let currentLevel = 1;
    let currentRule = "NAME_COLOR";
    let totalQuestions = 300;

    const levelRadios = document.querySelectorAll('input[name="level"]');
    const ruleRadios = document.querySelectorAll('input[name="rule"]');

    const cadenceSlider = document.getElementById('cadence');
    const intervalSlider = document.getElementById('interval');
    const cadenceValue = document.getElementById('cadenceValue');
    const intervalValue = document.getElementById('intervalValue');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const musicBtn = document.getElementById('musicBtn');
    const timerEl = document.getElementById('timer');
    const mathEl = document.getElementById('math');
    const charLeftEl = document.getElementById('charLeft');
    const charRightEl = document.getElementById('charRight');
    const totalStepsEl = document.getElementById('totalSteps');
    const footstepAudio = document.getElementById('footstep');

    const statsPanelStop = document.getElementById('statsPanelStop');
    const finalTimeStopEl = document.getElementById('finalTimeStop');
    const finalStepsStopEl = document.getElementById('finalStepsStop');
    const restartBtn = document.getElementById('restartBtn');

    const statsPanelPause = document.getElementById('statsPanelPause');
    const finalTimePauseEl = document.getElementById('finalTimePause');
    const finalStepsPauseEl = document.getElementById('finalStepsPause');
    const pauseRestartBtn = document.getElementById('pauseRestartBtn');
    const resumeBtn = document.getElementById('resumeBtn');

    const ruleOverlay = document.getElementById('ruleOverlay');
    const ruleOverlayText = document.getElementById('ruleOverlayText');

    let ytPlayer = null;

    function onYouTubeIframeAPIReady() {
      ytPlayer = new YT.Player('youtubePlayer', {});
    }

    (function loadYT() {
      const tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      const firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    })();

    function playFootstep() {
      footstepAudio.currentTime = 0;
      footstepAudio.play().catch(()=>{});
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60).toString().padStart(2,'0');
      const s = (seconds % 60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }

    function updateTimer() {
      timerEl.textContent = formatTime(timer);
    }

    function updateStats() {
      totalStepsEl.textContent = totalSteps;
    }

    function clearTimers() {
      if (intervalId) {
        cancelAnimationFrame(intervalId);
        intervalId = null;
      }
    }

    function resetGameState() {
      clearTimers();
      timer = 0;
      totalSteps = 0;
      isRunning = false;
      isPaused = false;
      updateTimer();
      updateStats();
      charLeftEl.textContent = "Ê∫ñÂÇô";
      charLeftEl.style.color = "#000000";
      charRightEl.textContent = "";
      statsPanelStop.classList.remove('show');
      statsPanelPause.classList.remove('show');
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      stopBtn.disabled = true;
      // ‰æùÁõÆÂâç level ÈáçÂª∫È°åÂ∫´
      questions = buildQuestionList(totalQuestions, currentLevel);
      currentIndex = -1;
    }

    function getCurrentIntervalSeconds() {
      if (currentLevel === 1) return 4;
      const v = parseInt(intervalSlider.value, 10);
      return isNaN(v) ? 4 : v;
    }

    function showQuestion() {
      currentIndex++;
      if (currentIndex >= questions.length) {
        questions = buildQuestionList(totalQuestions, currentLevel);
        currentIndex = 0;
      }
      const q = questions[currentIndex];
      if (!q) return;

      if (currentLevel === 3 || q.mode === "dual") {
        // Level IIIÔºöÂ∑¶Âè≥ÈõôÂ≠ó
        if (!q.left || !q.right) return;
        charLeftEl.textContent = q.left.char;
        charLeftEl.style.color = q.left.inkColor;
        charRightEl.textContent = q.right.char;
        charRightEl.style.color = q.right.inkColor;
        fitForDual(mathEl, 300, 80);
      } else {
        // Level I / IIÔºöÂñÆÂ≠ó
        charLeftEl.textContent = q.char;
        charLeftEl.style.color = q.inkColor;
        charRightEl.textContent = "";
        charRightEl.style.color = "#000000";
        fitForSingle(mathEl, 300, 80);
      }
    }

    function startLoop() {
      lastLoopTime = performance.now();
      lastStepTime = lastLoopTime;

      const firstQSec = getCurrentIntervalSeconds();
      nextQuestionTime = timer + firstQSec;

      const loop = (now) => {
        if (!isRunning || isPaused) return;

        const delta = now - lastLoopTime;
        if (delta >= 1000) {
          const addSec = Math.floor(delta / 1000);
          timer += addSec;
          lastLoopTime += addSec * 1000;
          updateTimer();
        }

        if (now - lastStepTime >= stepInterval) {
          playFootstep();
          totalSteps++;
          lastStepTime = now;
          updateStats();
        }

        if (timer >= nextQuestionTime) {
          showQuestion();
          const qSec = getCurrentIntervalSeconds();
          nextQuestionTime = timer + qSec;
        }

        intervalId = requestAnimationFrame(loop);
      };
      intervalId = requestAnimationFrame(loop);
    }

    function startTimer() {
      resetGameState();
      isRunning = true;
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;

      showQuestion();
      const qSec = getCurrentIntervalSeconds();
      nextQuestionTime = timer + qSec;
      startLoop();

      if (musicEnabled && ytPlayer && ytPlayer.playVideo) {
        ytPlayer.playVideo();
      }
    }

    function pauseGame() {
      if (!isRunning || isPaused) return;
      isPaused = true;
      clearTimers();

      finalTimePauseEl.textContent = formatTime(timer);
      finalStepsPauseEl.textContent = totalSteps;
      statsPanelPause.classList.add('show');

      pauseBtn.disabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;

      if (ytPlayer && ytPlayer.pauseVideo && musicEnabled) {
        ytPlayer.pauseVideo();
      }
    }

    function resumeGame() {
      if (!isRunning || !isPaused) return;
      isPaused = false;
      statsPanelPause.classList.remove('show');

      lastLoopTime = performance.now();
      lastStepTime = lastLoopTime;
      startLoop();

      pauseBtn.disabled = false;
      stopBtn.disabled = false;

      if (ytPlayer && ytPlayer.playVideo && musicEnabled) {
        ytPlayer.playVideo();
      }
    }

    function stopAll() {
      clearTimers();
      isRunning = false;
      isPaused = false;

      finalTimeStopEl.textContent = formatTime(timer);
      finalStepsStopEl.textContent = totalSteps;
      statsPanelStop.classList.add('show');
      statsPanelPause.classList.remove('show');

      startBtn.disabled = true;
      pauseBtn.disabled = true;
      stopBtn.disabled = true;

      if (ytPlayer && ytPlayer.pauseVideo && musicEnabled) {
        ytPlayer.pauseVideo();
      }
    }

    function showRuleOverlay(text) {
      ruleOverlayText.textContent = text;
      ruleOverlay.classList.add('show');
      setTimeout(() => {
        ruleOverlay.classList.remove('show');
      }, 5000);
    }

    musicBtn.onclick = () => {
      musicEnabled = !musicEnabled;
      if (musicEnabled) {
        musicBtn.textContent = 'üîá ÈóúÈü≥Ê®Ç';
        musicBtn.classList.add('active');
        if (ytPlayer && ytPlayer.playVideo) ytPlayer.playVideo();
      } else {
        musicBtn.textContent = 'üéµ Èü≥Ê®Ç';
        musicBtn.classList.remove('active');
        if (ytPlayer && ytPlayer.pauseVideo) ytPlayer.pauseVideo();
      }
    };

    cadenceSlider.oninput = () => {
      cadenceValue.textContent = cadenceSlider.value;
      const cadence = parseInt(cadenceSlider.value, 10);
      stepInterval = 60000 / cadence;
    };

    intervalSlider.oninput = () => {
      intervalValue.textContent = intervalSlider.value + 'Áßí';
    };

    levelRadios.forEach(r => {
      r.addEventListener('change', () => {
        currentLevel = parseInt(r.value, 10);
        // ÂàáÊèõÁ≠âÁ¥öÊôÇÈáçÂª∫È°åÂ∫´ÔºåÈÅøÂÖçËàäÈ°åÁõÆÂûãÊÖãÊ∑∑ÈÄ≤‰æÜ
        questions = buildQuestionList(totalQuestions, currentLevel);
        currentIndex = -1;
      });
    });

    ruleRadios.forEach(r => {
      r.addEventListener('change', () => {
        currentRule = r.value;
        if (currentRule === "NAME_COLOR") {
          showRuleOverlay("ÊîπÂè´Ëâ≤");
        } else {
          showRuleOverlay("ÊîπÂè´Â≠ó");
        }
      });
    });

    startBtn.onclick = () => { if (!isRunning) startTimer(); };
    pauseBtn.onclick = () => { pauseGame(); };
    stopBtn.onclick = () => { if (isRunning || isPaused) stopAll(); };

    restartBtn.onclick = () => {
      statsPanelStop.classList.remove('show');
      startTimer();
    };

    pauseRestartBtn.onclick = () => {
      statsPanelPause.classList.remove('show');
      startTimer();
    };

    resumeBtn.onclick = () => { resumeGame(); };

    // ÂàùÂßãÂåñ
    updateTimer();
    updateStats();
    questions = buildQuestionList(totalQuestions, currentLevel);
    fitForSingle(mathEl, 300, 80);
  </script>
